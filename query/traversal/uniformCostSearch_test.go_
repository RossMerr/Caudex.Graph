package traversal_test

import (
	"container/list"
	"errors"
	"fmt"
	"reflect"
	"strings"
	"testing"

	"github.com/RossMerr/Caudex.Graph"
	"github.com/RossMerr/Caudex.Graph/expressions"
	"github.com/RossMerr/Caudex.Graph/keyvalue"
	"github.com/RossMerr/Caudex.Graph/query"
	"github.com/RossMerr/Caudex.Graph/uuid"
)

var (
	errRecordNotFound = errors.New("Record Not found")
)

var (
	drw, _ = graph.NewVertex()
	cns, _ = graph.NewVertex()
	asp, _ = graph.NewVertex()
	bne, _ = graph.NewVertex()
	syd, _ = graph.NewVertex()
	cbr, _ = graph.NewVertex()
	mel, _ = graph.NewVertex()
	adl, _ = graph.NewVertex()
	per, _ = graph.NewVertex()
)

// https://neo4j.com/blog/graph-search-algorithm-basics/
// https://s3.amazonaws.com/dev.assets.neo4j.com/wp-content/uploads/20160715114833/Dijkstras-Algorithm-routing11.png
func init() {
	drw.SetLabel("drw")
	cns.SetLabel("cns")
	asp.SetLabel("asp")
	bne.SetLabel("bne")
	syd.SetLabel("syd")
	cbr.SetLabel("cbr")
	mel.SetLabel("mel")
	adl.SetLabel("adl")
	per.SetLabel("per")

	drw.AddDirectedEdgeWeight(cns, float64(30))
	drw.AddDirectedEdgeWeight(asp, float64(15))
	drw.AddDirectedEdgeWeight(per, float64(48))

	cns.AddDirectedEdgeWeight(drw, float64(30))
	cns.AddDirectedEdgeWeight(asp, float64(24))
	cns.AddDirectedEdgeWeight(bne, float64(22))

	asp.AddDirectedEdgeWeight(drw, float64(15))
	asp.AddDirectedEdgeWeight(cns, float64(24))
	asp.AddDirectedEdgeWeight(bne, float64(31))
	asp.AddDirectedEdgeWeight(cbr, float64(15))
	asp.AddDirectedEdgeWeight(adl, float64(15))

	bne.AddDirectedEdgeWeight(cns, float64(22))
	bne.AddDirectedEdgeWeight(asp, float64(31))
	bne.AddDirectedEdgeWeight(syd, float64(9))

	syd.AddDirectedEdgeWeight(bne, float64(9))
	syd.AddDirectedEdgeWeight(mel, float64(12))
	syd.AddDirectedEdgeWeight(cbr, float64(4))

	cbr.AddDirectedEdgeWeight(mel, float64(6))
	cbr.AddDirectedEdgeWeight(syd, float64(4))
	cbr.AddDirectedEdgeWeight(asp, float64(15))

	mel.AddDirectedEdgeWeight(syd, float64(12))
	mel.AddDirectedEdgeWeight(cbr, float64(6))
	mel.AddDirectedEdgeWeight(adl, float64(8))

	adl.AddDirectedEdgeWeight(mel, float64(8))
	adl.AddDirectedEdgeWeight(asp, float64(15))
	adl.AddDirectedEdgeWeight(per, float64(32))

	per.AddDirectedEdgeWeight(adl, float64(32))
	per.AddDirectedEdgeWeight(drw, float64(48))
}

func Test_UniformCostSearch(t *testing.T) {
	g := AustraliaGraph()

	path := make([]*query.PredicatePath, 0)
	path = append(path, toPredicateVertex())
	path = append(path, toPredicateEdge())
	path = append(path, toPredicateVertex())
	path = append(path, toPredicateEdge())
	path = append(path, toPredicateVertex())
	path = append(path, toPredicateEdge())
	path = append(path, toPredicateVertex())
	path = append(path, toPredicateEdge())
	path = append(path, toPredicateVertex())

	plan := query.NewPlan()
	it, err := plan.SearchPlan(g.ForEachTest(), path)
	if err != nil {
		t.Fatalf("Travers failed %+v", err)
	}
	result := ToIterator(it)

	count := len(result)
	if count != 5 {
		t.Fatalf("Expected result count to be %+v but was %+v", 5, count)
	}

	if !reflect.DeepEqual(result[0], syd) {
		t.Fatalf("Expected syd: \n%+v \nbut was \n%+v", syd, result[0])
	}

	if !reflect.DeepEqual(result[1], cbr) {
		t.Fatalf("Expected cbr: \n%+v \nbut was \n%+v", cbr, result[1])
	}

	if !reflect.DeepEqual(result[2], mel) {
		t.Fatalf("Expected mel: \n%+v \nbut was \n%+v", mel, result[2])
	}

	if !reflect.DeepEqual(result[3], adl) {
		t.Fatalf("Expected adl: \n%+v \nbut was \n%+v", adl, result[3])
	}

	if !reflect.DeepEqual(result[4], per) {
		t.Fatalf("Expected per: \n%+v \nbut was \n%+v", per, result[4])
	}
}

func AustraliaGraph() *StorageEngine {
	g := &StorageEngine{
		tKeyIndex: make(map[int]string),
		tKey:      make(map[string]*keyvalue.Any),
	}
	g.Create(drw, cns, asp, bne, syd, cbr, mel, adl, per)
	return g
}

type StorageEngine struct {
	tKeyIndex map[int]string
	tKey      map[string]*keyvalue.Any

	// kv   map[uuid.UUID]*keyvalue.KeyValue
	// keys []uuid.UUID
	// //	traversal query.Traversal
}

// Create adds a array of vertices to the persistence
func (se *StorageEngine) Create(c ...*graph.Vertex) error {
	for _, v := range c {
		triples := keyvalue.MarshalKeyValue(v)
		transposes := keyvalue.MarshalKeyValueTranspose(v)
		var errstrings []string

		for i := 0; i < len(triples); i++ {
			triple := triples[i]
			se.tKeyIndex[len(se.tKey)] = string(triple.Key)
			se.tKey[string(triple.Key)] = triple.Value
		}

		if len(errstrings) > 0 {
			return fmt.Errorf(strings.Join(errstrings, "\n"))
		}
	}

	return nil
}

// Delete the array of vertices from the persistence
func (se *StorageEngine) Delete(c ...*graph.Vertex) error {
	return nil
}

// Update the array of vertices from the persistence
func (se *StorageEngine) Update(c ...*graph.Vertex) error {
	se.Create(c...)
	return nil
}

func (se *StorageEngine) Query(str string) (*graph.Query, error) {
	return nil, nil
}

// func (se *StorageEngine) Fetch(id uuid.UUID) (*graph.Vertex, error) {
// 	if v, ok := se.vertices[id]; ok {
// 		return &v, nil
// 	} else {
// 		return nil, errRecordNotFound
// 	}
// }

func (se *StorageEngine) Close() {

}

func (se *StorageEngine) ForEach() query.IteratorUUID {
	position := 0
	length := len(se.tKey)
	return func() (uuid.UUID, bool) {
		for position < length {
			key := se.tKeyIndex[position]
			id, _ := uuid.ParseUUID(key)
			position = position + 1
			return id, true
		}
		return uuid.UUID{}, false
	}
}

func (se *StorageEngine) ForEachTest() query.IteratorFrontier {
	ok := false
	return func() (*query.Frontier, bool) {
		ok = expressions.XORSwap(ok)
		if ok {
			kv := keyvalue.MarshalKeyValue(syd)
			f := query.NewFrontier(kv[0].UUID(), "")
			return &f, ok
		}
		return nil, ok
	}
}

func ToIterator(i query.IteratorFrontier) []*uuid.UUID {
	results := make([]*uuid.UUID, 0)

	for frontier, ok := i(); ok; frontier, ok = i() {
		if frontier.Len() > 0 {
			parts := frontier.OptimalPath()
			for _, i := range parts {
				results = append(results, i.UUID)
			}
		}
	}
	return results
}

func toPredicateVertex() *query.Predicate {
	return func(from, to *uuid.UUID, depth int) (string, query.Traverse, float64) {
		if from == per.ID() {
			return "", query.Matched, 0
		}

		return "", query.Failed, 0
	}

}

func toPredicateEdge() *query.Predicate {
	return func(from, to *uuid.UUID, depth int) (string, query.Traverse, float64) {
		if to != per.ID() {
			return "", query.Visiting, 0
		}

		return "", query.Matching, 0
	}
}

func index(l *list.List, i int) interface{} {
	e := l.Front()
	for index := 1; index < i; index++ {
		e = e.Next()
	}

	return e.Value
}
