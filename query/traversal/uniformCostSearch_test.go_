package traversal_test

import (
	"bytes"
	"container/list"
	"errors"
	"fmt"
	"reflect"
	"strings"
	"testing"

	"github.com/RossMerr/Caudex.Graph"
	"github.com/RossMerr/Caudex.Graph/expressions"
	"github.com/RossMerr/Caudex.Graph/keyvalue"
	"github.com/RossMerr/Caudex.Graph/query"
	"github.com/RossMerr/Caudex.Graph/query/cypher"
	"github.com/RossMerr/Caudex.Graph/query/cypher/ast"
	"github.com/RossMerr/Caudex.Graph/uuid"
)

var (
	errRecordNotFound = errors.New("Record Not found")
)

var (
	drw, _ = graph.NewVertex()
	cns, _ = graph.NewVertex()
	asp, _ = graph.NewVertex()
	bne, _ = graph.NewVertex()
	syd, _ = graph.NewVertex()
	cbr, _ = graph.NewVertex()
	mel, _ = graph.NewVertex()
	adl, _ = graph.NewVertex()
	per, _ = graph.NewVertex()
)

// https://neo4j.com/blog/graph-search-algorithm-basics/
// https://s3.amazonaws.com/dev.assets.neo4j.com/wp-content/uploads/20160715114833/Dijkstras-Algorithm-routing11.png
func init() {
	drw.SetLabel("drw")
	cns.SetLabel("cns")
	asp.SetLabel("asp")
	bne.SetLabel("bne")
	syd.SetLabel("syd")
	cbr.SetLabel("cbr")
	mel.SetLabel("mel")
	adl.SetLabel("adl")
	per.SetLabel("per")

	drw.AddDirectedEdgeWeight(cns, float64(30))
	drw.AddDirectedEdgeWeight(asp, float64(15))
	drw.AddDirectedEdgeWeight(per, float64(48))

	cns.AddDirectedEdgeWeight(drw, float64(30))
	cns.AddDirectedEdgeWeight(asp, float64(24))
	cns.AddDirectedEdgeWeight(bne, float64(22))

	asp.AddDirectedEdgeWeight(drw, float64(15))
	asp.AddDirectedEdgeWeight(cns, float64(24))
	asp.AddDirectedEdgeWeight(bne, float64(31))
	asp.AddDirectedEdgeWeight(cbr, float64(15))
	asp.AddDirectedEdgeWeight(adl, float64(15))

	bne.AddDirectedEdgeWeight(cns, float64(22))
	bne.AddDirectedEdgeWeight(asp, float64(31))
	bne.AddDirectedEdgeWeight(syd, float64(9))

	syd.AddDirectedEdgeWeight(bne, float64(9))
	syd.AddDirectedEdgeWeight(mel, float64(12))
	syd.AddDirectedEdgeWeight(cbr, float64(4))

	cbr.AddDirectedEdgeWeight(mel, float64(6))
	cbr.AddDirectedEdgeWeight(syd, float64(4))
	cbr.AddDirectedEdgeWeight(asp, float64(15))

	mel.AddDirectedEdgeWeight(syd, float64(12))
	mel.AddDirectedEdgeWeight(cbr, float64(6))
	mel.AddDirectedEdgeWeight(adl, float64(8))

	adl.AddDirectedEdgeWeight(mel, float64(8))
	adl.AddDirectedEdgeWeight(asp, float64(15))
	adl.AddDirectedEdgeWeight(per, float64(32))

	per.AddDirectedEdgeWeight(adl, float64(32))
	per.AddDirectedEdgeWeight(drw, float64(48))
}

func Test_UniformCostSearch(t *testing.T) {
	g := AustraliaGraph()

	qb := &queryBuilder{Storage: g}
	patterns := []ast.Patn{}

	plan := cypher.NewPlan(qb, g)
	it, err := plan.SearchPlan(g.ForEachTest(), patterns)
	if err != nil {
		t.Fatalf("Travers failed %+v", err)
	}
	result := ToIterator(it)

	count := len(result)
	if count != 5 {
		t.Fatalf("Expected result count to be %+v but was %+v", 5, count)
	}

	if !reflect.DeepEqual(result[0], syd) {
		t.Fatalf("Expected syd: \n%+v \nbut was \n%+v", syd, result[0])
	}

	if !reflect.DeepEqual(result[1], cbr) {
		t.Fatalf("Expected cbr: \n%+v \nbut was \n%+v", cbr, result[1])
	}

	if !reflect.DeepEqual(result[2], mel) {
		t.Fatalf("Expected mel: \n%+v \nbut was \n%+v", mel, result[2])
	}

	if !reflect.DeepEqual(result[3], adl) {
		t.Fatalf("Expected adl: \n%+v \nbut was \n%+v", adl, result[3])
	}

	if !reflect.DeepEqual(result[4], per) {
		t.Fatalf("Expected per: \n%+v \nbut was \n%+v", per, result[4])
	}
}

func AustraliaGraph() *storageEngine {
	g := &storageEngine{
		tKeyIndex: make(map[int]string),
		tKey:      make(map[string]*keyvalue.Any),
	}
	g.Create(drw, cns, asp, bne, syd, cbr, mel, adl, per)
	return g
}

var _ query.Storage = (*storageEngine)(nil)

type storageEngine struct {
	tKeyIndex map[int]string
	tKey      map[string]*keyvalue.Any
}

// Create adds a array of vertices to the persistence
func (se *storageEngine) Create(c ...*graph.Vertex) error {
	for _, v := range c {
		triples := keyvalue.MarshalKeyValue(v)
		var errstrings []string

		for i := 0; i < len(triples); i++ {
			triple := triples[i]
			se.tKeyIndex[len(se.tKey)] = string(triple.Key)
			se.tKey[string(triple.Key)] = triple.Value
		}

		if len(errstrings) > 0 {
			return fmt.Errorf(strings.Join(errstrings, "\n"))
		}
	}

	return nil
}

// Delete the array of vertices from the persistence
func (se *storageEngine) Delete(c ...*graph.Vertex) error {
	return nil
}

// Update the array of vertices from the persistence
func (se *storageEngine) Update(c ...*graph.Vertex) error {
	se.Create(c...)
	return nil
}

func (se *storageEngine) Query(str string) (*graph.Query, error) {
	return nil, nil
}

func (se *storageEngine) Close() {

}

func (se *storageEngine) ForEach() query.IteratorUUID {
	position := 0
	length := len(se.tKey)
	return func() (*uuid.UUID, bool) {
		for position < length {
			key := []byte(se.tKeyIndex[position])
			kv := &keyvalue.KeyValue{
				Key: key,
			}
			position = position + 1
			return kv.UUID(), true
		}
		return nil, false
	}
}

func (se *storageEngine) Edges(id *uuid.UUID) query.IteratorUUIDWeight {
	position := 0
	length := len(se.tKey)
	p := keyvalue.RelationshipPrefix(id)
	return func() (*uuid.UUID, float64, bool) {
		for position < length {
			key := []byte(se.tKeyIndex[position])
			position = position + 1

			if bytes.HasPrefix(key, p) {
				value := se.tKey[string(key)]
				kv := &keyvalue.KeyValue{
					Key:   key,
					Value: value,
				}
				return kv.To(), kv.Weight(), true
			}
		}
		return nil, 0, false
	}
}

func (se *storageEngine) HasPrefix(prefix []byte) query.Iterator {
	position := 0
	length := len(se.tKey)
	return func() (interface{}, bool) {
		for position < length {
			key := []byte(se.tKeyIndex[position])
			position = position + 1

			if bytes.HasPrefix(key, prefix) {
				v := se.tKey[string(key)]
				kv := &keyvalue.KeyValue{Key: key, Value: v}
				return kv, true
			}
		}

		return nil, false
	}
}

func (se *storageEngine) ForEachTest() query.IteratorFrontier {
	ok := false
	return func() (*query.Frontier, bool) {
		ok = expressions.XORSwap(ok)
		if ok {
			kv := keyvalue.MarshalKeyValue(syd)
			f := query.NewFrontier(kv[0].UUID(), "")
			return &f, ok
		}
		return nil, ok
	}
}

func ToIterator(i query.IteratorFrontier) []*uuid.UUID {
	results := make([]*uuid.UUID, 0)

	for frontier, ok := i(); ok; frontier, ok = i() {
		if frontier.Len() > 0 {
			parts := frontier.OptimalPath()
			for _, i := range parts {
				results = append(results, i.UUID)
			}
		}
	}
	return results
}

type queryBuilder struct {
	Storage query.Storage
}

func (qb *queryBuilder) Predicate([]ast.Patn) ([]query.Predicate, error) {
	path := make([]query.Predicate, 0)
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())
	path = append(path, qb.toPredicate())

	return path, nil
}

func (qb *queryBuilder) toPredicate() query.Predicate {
	return func(from, to *uuid.UUID, depth int) (string, query.Traverse) {
		if to == nil {
			if from == per.ID() {

				return "", query.Matched
			}

			return "", query.Failed
		}

		if to != per.ID() {
			return "", query.Visiting
		}

		return "", query.Matching
	}

}

func index(l *list.List, i int) interface{} {
	e := l.Front()
	for index := 1; index < i; index++ {
		e = e.Next()
	}

	return e.Value
}
